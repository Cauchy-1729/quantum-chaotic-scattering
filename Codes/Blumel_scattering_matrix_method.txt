{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 170,
   "id": "1fa26d54",
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "# Physical parameters\n",
    "mass = 1.0\n",
    "hbar = (1/5)**0.5\n",
    "I_0 = 10.0\n",
    "E = 2.0\n",
    "V0 = 3.0\n",
    "xi = 10.0\n",
    "\n",
    "# Channel indices\n",
    "j_max = 6      # Increase for more channels if desired\n",
    "j_vals = np.arange(-j_max, j_max+1)\n",
    "\n",
    "# Compute k_j for each channel\n",
    "k_vals = np.zeros(len(j_vals), dtype=complex)\n",
    "for idx, j in enumerate(j_vals):\n",
    "    val = 2 * mass * (E - ((j ** 2) * (hbar**2) / (2 * I_0)))\n",
    "    if val >= 0:\n",
    "        k_vals[idx] = np.sqrt(val)\n",
    "    else:\n",
    "        k_vals[idx] = 1j * np.sqrt(-val)\n",
    "\n",
    "# Spatial grid\n",
    "N = 300\n",
    "L = 40.0\n",
    "x = np.linspace(-L, L, N)\n",
    "dx = x[1] - x[0]\n",
    "\n",
    "print(x)  \n",
    "print(k_vals)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 169,
   "id": "70ab62d3",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Green's function for channel j\n",
    "def greens_function(xn, xm, kj):\n",
    "    # Outgoing Green's function as per equation\n",
    "    return -(1j * mass) / (hbar**2 * kj) * np.exp(1j * kj * np.abs(xn - xm))\n",
    "\n",
    "# Coupled-channel potential (sum of three Gaussians)\n",
    "def potential_triplet(x_p, xi=xi):\n",
    "    m_vals = np.array([-1, 0, 1])\n",
    "    return (V0)*(np.sum([np.exp(-(x_p - m*xi)**2) for m in m_vals]))\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 108,
   "id": "92d414bf",
   "metadata": {},
   "outputs": [],
   "source": [
    "n_ch = len(j_vals)\n",
    "dim = N * n_ch\n",
    "K = np.zeros((dim, dim), dtype=np.complex128)\n",
    "\n",
    "# For each j,x pair, couple only j to j+1/j-1 via the potential\n",
    "for j_idx, j in enumerate(j_vals):\n",
    "    kj = k_vals[j_idx]\n",
    "    for xn_idx, xn in enumerate(x):\n",
    "        row_idx = j_idx * N + xn_idx\n",
    "        # Coupling to j-1\n",
    "        l = j - 1\n",
    "        if l in j_vals:\n",
    "            l_idx = np.where(j_vals == l)[0][0]\n",
    "            for xm_idx, xm in enumerate(x):\n",
    "                col_idx = l_idx * N + xm_idx\n",
    "                G_val = greens_function(xn, xm, kj)\n",
    "                V_val = potential_triplet(xm)\n",
    "                K[row_idx, col_idx] += G_val * V_val * dx\n",
    "        # Coupling to j+1\n",
    "        l = j + 1\n",
    "        if l in j_vals:\n",
    "            l_idx = np.where(j_vals == l)[0][0]\n",
    "            for xm_idx, xm in enumerate(x):\n",
    "                col_idx = l_idx * N + xm_idx\n",
    "                G_val = greens_function(xn, xm, kj)\n",
    "                V_val = potential_triplet(xm)\n",
    "                K[row_idx, col_idx] += G_val * V_val * dx\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 109,
   "id": "29fb8eea",
   "metadata": {},
   "outputs": [],
   "source": [
    "print((K.shape))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 110,
   "id": "73138ad9",
   "metadata": {},
   "outputs": [],
   "source": [
    "print(K)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 111,
   "id": "5d009592",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Incident wave: only in the j=0 channel\n",
    "phi = np.zeros(dim, dtype=np.complex128)\n",
    "inc_channel = np.where(j_vals == 0)[0][0]\n",
    "for xn_idx, xn_val in enumerate(x):\n",
    "    idx = inc_channel * N + xn_idx\n",
    "    phi[idx] = np.exp(1j * k_vals[inc_channel] * xn_val)\n",
    "\n",
    "# inc_channel2 = np.where(j_vals == 1)[0][0]\n",
    "# for xn_idx, xn_val in enumerate(x):\n",
    "#     idx = inc_channel2 * N + xn_idx\n",
    "#     phi[idx] = np.exp(1j * k_vals[inc_channel2] * xn_val)\n",
    "\n",
    "# Solve (I - K) psi = phi\n",
    "A = np.eye(dim, dtype=np.complex128) - K\n",
    "psi = np.linalg.solve(A, phi)\n",
    "psi_mat = psi.reshape((n_ch, N))  # shape: (num_channels, N)\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 112,
   "id": "6cf5f20f",
   "metadata": {},
   "outputs": [],
   "source": [
    "phi = phi.reshape((n_ch,N))\n",
    "plt.plot(x, phi[6])\n",
    "plt.plot(x,phi[7])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 113,
   "id": "0506d76f",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Choose x regions well outside the scattering region\n",
    "refl_mask = x < -L/2\n",
    "trans_mask = x > L/2\n",
    "\n",
    "r_coeffs = np.zeros(n_ch, dtype=np.complex128)\n",
    "t_coeffs = np.zeros(n_ch, dtype=np.complex128)\n",
    "\n",
    "for idx_ch, kj in enumerate(k_vals):\n",
    "    psi_refl = psi_mat[idx_ch, refl_mask]\n",
    "    x_refl = x[refl_mask]\n",
    "    M_refl = np.vstack([np.exp(1j*kj*x_refl), np.exp(-1j*kj*x_refl)]).T\n",
    "    coeffs_refl, _, _, _ = np.linalg.lstsq(M_refl, psi_refl, rcond=None)\n",
    "    r_coeffs[idx_ch] = coeffs_refl[1]  # reflected amplitude\n",
    "\n",
    "    psi_trans = psi_mat[idx_ch, trans_mask]\n",
    "    x_trans = x[trans_mask]\n",
    "    ratios = psi_trans / np.exp(1j*kj*x_trans)\n",
    "    t_coeffs[idx_ch] = np.mean(ratios)                                                    \n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 114,
   "id": "3aa456a5",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "plt.plot(x,psi_mat[0])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 115,
   "id": "0dcaa0f9",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Choose x regions well outside the scattering region\n",
    "refl_mask = x < -L/2\n",
    "trans_mask = x > L/2\n",
    "\n",
    "r_coeffs = np.zeros(n_ch, dtype=np.complex128)\n",
    "t_coeffs = np.zeros(n_ch, dtype=np.complex128)\n",
    "\n",
    "for idx_ch, kj in enumerate(k_vals):\n",
    "    psi_refl = psi_mat[idx_ch, refl_mask]\n",
    "    x_refl = x[refl_mask]\n",
    "    M_refl = np.vstack([np.exp(1j*kj*x_refl), np.exp(-1j*kj*x_refl)]).T\n",
    "    coeffs_refl, _, _, _ = np.linalg.lstsq(M_refl, psi_refl, rcond=None)\n",
    "    r_coeffs[idx_ch] = coeffs_refl[1]  # reflected amplitude\n",
    "    \n",
    "\n",
    "    psi_trans = psi_mat[idx_ch, trans_mask]\n",
    "    x_trans = x[trans_mask]\n",
    "    ratios = psi_trans / np.exp(1j*kj*x_trans)\n",
    "    t_coeffs[idx_ch] = np.mean(ratios)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 116,
   "id": "988a5801",
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "print(t_coeffs)\n",
    "print(r_coeffs)\n",
    "# np.sum() # Check if adding transmission and reflection probabilities gives 1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 117,
   "id": "3d912a68",
   "metadata": {},
   "outputs": [],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "\n",
    "# Magnitude squared of reflection and transmission in each channel\n",
    "plt.figure(figsize=(12,5))\n",
    "plt.plot(j_vals, np.abs(r_coeffs)**2, 'ro-', label='|Reflection|^2')\n",
    "plt.plot(j_vals, np.abs(t_coeffs)**2, 'bo-', label='|Transmission|^2')\n",
    "plt.xlabel('Channel index j')\n",
    "plt.ylabel('|Coefficient|²')\n",
    "plt.legend()\n",
    "plt.title('Reflection and Transmission vs Channel Index')\n",
    "plt.grid(True)\n",
    "plt.show()\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 118,
   "id": "1955f2a5",
   "metadata": {},
   "outputs": [],
   "source": [
    "print(np.sum(np.abs(r_coeffs)**2) + np.sum(np.abs(t_coeffs)**2)) "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "673bd187",
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": 119,
   "id": "bd7d3ea7",
   "metadata": {
    "scrolled": false
   },
   "outputs": [],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "\n",
    "## Wavefunction Visualization\n",
    "plt.figure(figsize=(16, 32))\n",
    "\n",
    "for ch_idx, j in enumerate(j_vals):\n",
    "    psi_ch = psi_mat[ch_idx]\n",
    "    plt.subplot(((len(j_vals)//2) + 1), 2, ch_idx+1)\n",
    "    plt.plot(x, psi_ch.real, 'b', label=f'Real j={j}')\n",
    "    plt.plot(x, psi_ch.imag, 'r--', label=f'Imag j={j}')\n",
    "    plt.xlabel('x')\n",
    "    plt.ylabel('ψ(x)')    \n",
    "    plt.title(f'Channel {j}')\n",
    "    plt.legend()\n",
    "    plt.grid(True)\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.show()\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 120,
   "id": "13b739cf",
   "metadata": {},
   "outputs": [],
   "source": [
    "def calculate_scattering_for_incident_channel(inc_channel_idx, k_vals, j_vals, x, dx, N, n_ch, K):\n",
    "    \"\"\"\n",
    "    Calculate scattering coefficients for a specific incident channel\n",
    "    Returns reflection and transmission coefficients for all channels\n",
    "    \"\"\"\n",
    "    dim = N * n_ch\n",
    "    \n",
    "    # Incident wave in specified channel\n",
    "    phi = np.zeros(dim, dtype=np.complex128)\n",
    "    for xn_idx, xn_val in enumerate(x):\n",
    "        idx = inc_channel_idx * N + xn_idx\n",
    "        phi[idx] = np.exp(1j * k_vals[inc_channel_idx] * xn_val)\n",
    "    \n",
    "    # Solve linear system\n",
    "    A = np.eye(dim, dtype=np.complex128) - K\n",
    "    psi = np.linalg.solve(A, phi)\n",
    "    psi_mat = psi.reshape((n_ch, N))\n",
    "    \n",
    "    # Extract coefficients\n",
    "    refl_mask = x < -L/2\n",
    "    trans_mask = x > L/2\n",
    "    \n",
    "    r_coeffs = np.zeros(n_ch, dtype=np.complex128)\n",
    "    t_coeffs = np.zeros(n_ch, dtype=np.complex128)\n",
    "    \n",
    "    for idx_ch, kj in enumerate(k_vals):\n",
    "        psi_refl = psi_mat[idx_ch, refl_mask]\n",
    "        x_refl = x[refl_mask]\n",
    "        M_refl = np.vstack([np.exp(1j*kj*x_refl), np.exp(-1j*kj*x_refl)]).T\n",
    "        coeffs_refl, _, _, _ = np.linalg.lstsq(M_refl, psi_refl, rcond=None)\n",
    "        r_coeffs[idx_ch] = coeffs_refl[1]  # reflected amplitude\n",
    "        \n",
    "        psi_trans = psi_mat[idx_ch, trans_mask]\n",
    "        x_trans = x[trans_mask]\n",
    "        ratios = psi_trans / np.exp(1j*kj*x_trans)\n",
    "        t_coeffs[idx_ch] = np.mean(ratios)\n",
    "    \n",
    "    # Return as f_coeffs array: [channel, 0=reflection/1=transmission]\n",
    "    f_coeffs = np.zeros((n_ch, 2), dtype=np.complex128)\n",
    "    f_coeffs[:, 0] = r_coeffs\n",
    "    f_coeffs[:, 1] = t_coeffs\n",
    "    \n",
    "    return f_coeffs\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 121,
   "id": "366a8a57",
   "metadata": {},
   "outputs": [],
   "source": [
    "# # Define incident channel range\n",
    "# inc_channel_range = range(-6, 7)  # -3 to +3\n",
    "# incident_channel_indices = []\n",
    "\n",
    "# # Get indices of incident channels that exist in j_vals\n",
    "# for j_inc in inc_channel_range:\n",
    "#     if j_inc in j_vals:\n",
    "#         idx = np.where(j_vals == j_inc)[0][0]\n",
    "#         incident_channel_indices.append(idx)\n",
    "\n",
    "# print(f\"Incident channel indices: {incident_channel_indices}\")\n",
    "# print(f\"Corresponding j values: {[j_vals[i] for i in incident_channel_indices]}\")\n",
    "\n",
    "# # Calculate f-coefficients for all incident channels\n",
    "# all_f_coeffs = {}\n",
    "\n",
    "# print(\"Calculating scattering coefficients for each incident channel...\")\n",
    "# for inc_idx in incident_channel_indices:\n",
    "#     j_inc = j_vals[inc_idx]\n",
    "#     print(f\"Processing incident channel j = {j_inc}\")\n",
    "    \n",
    "#     f_coeffs = calculate_scattering_for_incident_channel(inc_idx, k_vals, j_vals, x, dx, N, n_ch, K)\n",
    "#     all_f_coeffs[inc_idx] = f_coeffs\n",
    "    \n",
    "#     # Quick verification - print total probability\n",
    "#     total_prob = np.sum(np.abs(f_coeffs[:, 0])**2 + np.abs(f_coeffs[:, 1])**2)\n",
    "#     print(f\"  Total probability for j={j_inc}: {total_prob:.6f}\")\n",
    "\n",
    "# print(\"Completed calculation for all incident channels\")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 122,
   "id": "d9a3c02d",
   "metadata": {},
   "outputs": [],
   "source": [
    "def construct_full_s_matrix(all_f_coeffs, k_vals, j_vals):\n",
    "    \"\"\"\n",
    "    Construct the full S-matrix from f-coefficients\n",
    "    S-matrix structure: (T R)\n",
    "                       (R T)\n",
    "    \"\"\"\n",
    "    # Get open channel indices (real k values)\n",
    "    open_channel_indices = [i for i in range(len(j_vals)) if np.imag(k_vals[i]) < 1e-10]\n",
    "    n_open_channels = len(open_channel_indices)\n",
    "    \n",
    "    print(f\"Open channels: {[j_vals[i] for i in open_channel_indices]}\")\n",
    "    print(f\"Number of open channels: {n_open_channels}\")\n",
    "    \n",
    "    # Initialize S-matrix (2N x 2N for N open channels)\n",
    "    S_matrix = np.zeros((2*n_open_channels, 2*n_open_channels), dtype=np.complex128)\n",
    "    \n",
    "    # Fill the S-matrix\n",
    "    for i, inc_channel in enumerate(open_channel_indices):\n",
    "        if inc_channel in all_f_coeffs:\n",
    "            f_coeffs = all_f_coeffs[inc_channel]\n",
    "            \n",
    "            for j, out_channel in enumerate(open_channel_indices):\n",
    "                # Extract coefficients\n",
    "                r_coeff = f_coeffs[out_channel, 0]  # reflection\n",
    "                t_coeff = f_coeffs[out_channel, 1]  # transmission\n",
    "                \n",
    "                # Fill 2x2 block: (T R)\n",
    "                #                (R T)\n",
    "                S_matrix[2*j, 2*i] = t_coeff      # T_ji\n",
    "                S_matrix[2*j, 2*i+1] = r_coeff    # R_ji  \n",
    "                S_matrix[2*j+1, 2*i] = r_coeff    # R_ji\n",
    "                S_matrix[2*j+1, 2*i+1] = t_coeff  # T_ji\n",
    "    \n",
    "    return S_matrix\n",
    "\n",
    "# Construct S-matrix for current energy\n",
    "# S_matrix = construct_full_s_matrix(all_f_coeffs, k_vals, j_vals)\n",
    "# print(f\"S-matrix shape: {S_matrix.shape}\")\n",
    "\n",
    "# # Check unitarity\n",
    "# S_dagger = S_matrix.conj().T\n",
    "# unitarity_check = S_dagger @ S_matrix\n",
    "# identity_check = np.allclose(unitarity_check, np.eye(S_matrix.shape[0]), rtol=1e-3, atol=1e-3)\n",
    "# print(f\"S-matrix unitarity check: {'PASSED' if identity_check else 'FAILED'}\")\n",
    "# print(f\"Max deviation from identity: {np.max(np.abs(unitarity_check - np.eye(S_matrix.shape[0]))):.6f}\")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 123,
   "id": "5b4bb76d",
   "metadata": {},
   "outputs": [],
   "source": [
    "def build_K_matrix(k_vals, j_vals, x, dx, n_ch):\n",
    "    \"\"\"\n",
    "    Construct the coupled-channel K matrix for given k_vals, channels, and spatial grid.\n",
    "    Returns the K matrix.\n",
    "    \"\"\"\n",
    "    N = len(x)\n",
    "    dim = n_ch * N\n",
    "    K = np.zeros((dim, dim), dtype=np.complex128)\n",
    "\n",
    "    for j_idx, j in enumerate(j_vals):\n",
    "        kj = k_vals[j_idx]\n",
    "        for xn_idx, xn in enumerate(x):\n",
    "            row_idx = j_idx * N + xn_idx\n",
    "            # Coupling to j-1\n",
    "            l = j - 1\n",
    "            if l in j_vals:\n",
    "                l_idx = np.where(j_vals == l)[0][0]\n",
    "                for xm_idx, xm in enumerate(x):\n",
    "                    col_idx = l_idx * N + xm_idx\n",
    "                    G_val = greens_function(xn, xm, kj)\n",
    "                    V_val = potential_triplet(xm)\n",
    "                    K[row_idx, col_idx] += G_val * V_val * dx\n",
    "            # Coupling to j+1\n",
    "            l = j + 1\n",
    "            if l in j_vals:\n",
    "                l_idx = np.where(j_vals == l)[0][0]\n",
    "                for xm_idx, xm in enumerate(x):\n",
    "                    col_idx = l_idx * N + xm_idx\n",
    "                    G_val = greens_function(xn, xm, kj)\n",
    "                    V_val = potential_triplet(xm)\n",
    "                    K[row_idx, col_idx] += G_val * V_val * dx\n",
    "    return K\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 124,
   "id": "8f801b6d",
   "metadata": {},
   "outputs": [],
   "source": [
    "def calculate_k_values_for_energy(E_val, j_vals, mass, hbar, I_0):\n",
    "    \"\"\"Calculate k values for given energy\"\"\"\n",
    "    k_vals_new = np.zeros(len(j_vals), dtype=complex)\n",
    "    for idx, j in enumerate(j_vals):\n",
    "        val = 2 * mass * (E_val - ((j ** 2) * (hbar**2) / (2 * I_0)))\n",
    "        if val >= 0:\n",
    "            k_vals_new[idx] = np.sqrt(val)\n",
    "        else:\n",
    "            k_vals_new[idx] = 1j * np.sqrt(-val)\n",
    "    return k_vals_new\n",
    "\n",
    "def single_energy_s_matrix(E_val, j_vals, x, dx, N, n_ch, mass, hbar, I_0):\n",
    "    \"\"\"Calculate S-matrix for a single energy with K matrix construction\"\"\"\n",
    "    # Calculate k values for this energy\n",
    "    k_vals_E = calculate_k_values_for_energy(E_val, j_vals, mass, hbar, I_0)\n",
    "    \n",
    "    # Build K matrix for this energy\n",
    "    print(f\"Building K matrix for E = {E_val:.3f}\")\n",
    "    K = build_K_matrix(k_vals_E, j_vals, x, dx, n_ch)\n",
    "    \n",
    "    # Get open channels for this energy\n",
    "    open_channel_indices = [i for i in range(len(j_vals)) if np.imag(k_vals_E[i]) < 1e-10]\n",
    "    \n",
    "    # Only calculate for incident channels that are open and in range -3 to +3\n",
    "    incident_channels = []\n",
    "    inc_channel_range = range(-6, 7)\n",
    "    for j_inc in inc_channel_range:\n",
    "        if j_inc in j_vals:\n",
    "            idx = np.where(j_vals == j_inc)[0][0]\n",
    "            if idx in open_channel_indices:\n",
    "                incident_channels.append(idx)\n",
    "    \n",
    "    print(f\"  Open incident channels: {[j_vals[i] for i in incident_channels]}\")\n",
    "    \n",
    "    # Calculate f-coefficients for all incident channels\n",
    "    all_f_coeffs_E = {}\n",
    "    for inc_idx in incident_channels:\n",
    "        j_inc = j_vals[inc_idx]\n",
    "        print(f\"  Processing incident channel j = {j_inc}\")\n",
    "        \n",
    "        f_coeffs = calculate_scattering_for_incident_channel(inc_idx, k_vals_E, j_vals, x, dx, N, n_ch, K)\n",
    "        all_f_coeffs_E[inc_idx] = f_coeffs\n",
    "        \n",
    "        # Quick verification\n",
    "        total_prob = np.sum(np.abs(f_coeffs[:, 0])**2 + np.abs(f_coeffs[:, 1])**2)\n",
    "        print(f\"    Total probability: {total_prob:.6f}\")\n",
    "    \n",
    "    # Construct S-matrix\n",
    "    S_matrix_E = construct_full_s_matrix(all_f_coeffs_E, k_vals_E, j_vals)\n",
    "    \n",
    "    return S_matrix_E, k_vals_E\n",
    "\n",
    "# Test for a single energy\n",
    "# print(\"Testing S-matrix calculation for single energy...\")\n",
    "# E_test = 2.0\n",
    "# S_test, k_test = single_energy_s_matrix(E_test, j_vals, x, dx, N, n_ch, mass, hbar, I_0)\n",
    "# print(f\"S-matrix shape for E={E_test}: {S_test.shape}\")\n",
    "\n",
    "# # Check unitarity\n",
    "# S_dagger = S_test.conj().T\n",
    "# unitarity_check = S_dagger @ S_test\n",
    "# identity_check = np.allclose(unitarity_check, np.eye(S_test.shape[0]), rtol=1e-3, atol=1e-3)\n",
    "# print(f\"S-matrix unitarity check: {identity_check}\")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 171,
   "id": "9ae1674e",
   "metadata": {},
   "outputs": [],
   "source": [
    "def calculate_level_statistics(energy_range, j_vals, x, dx, N, n_ch, mass, hbar, I_0):\n",
    "    \"\"\"Calculate level spacing statistics over energy range\"\"\"\n",
    "    all_eigenphases = []\n",
    "    all_S_matrices = []\n",
    "    valid_energies = []\n",
    "    \n",
    "    print(f\"Calculating level statistics for {len(energy_range)} energy points...\")\n",
    "    \n",
    "    for i, E_val in enumerate(energy_range):\n",
    "        print(f\"Processing energy {i+1}/{len(energy_range)}: E = {E_val:.3f}\")\n",
    "        \n",
    "        try:\n",
    "            S_matrix_E, k_vals_E = single_energy_s_matrix(E_val, j_vals, x, dx, N, n_ch, mass, hbar, I_0)\n",
    "            \n",
    "            # Skip if S-matrix is too small or has issues\n",
    "            if S_matrix_E.shape[0] < 4:\n",
    "                print(f\"  Skipping E={E_val:.3f}: S-matrix too small\")\n",
    "                continue\n",
    "            \n",
    "            # Get eigenvalues and phases\n",
    "            eigenvalues = np.linalg.eigvals(S_matrix_E)\n",
    "            phases = np.angle(eigenvalues)\n",
    "            \n",
    "            # Remove nan or inf values\n",
    "            phases = phases[np.isfinite(phases)]\n",
    "            \n",
    "            if len(phases) > 2:  # Need at least 3 phases for meaningful statistics\n",
    "                all_eigenphases.append(phases)\n",
    "                all_S_matrices.append(S_matrix_E)\n",
    "                valid_energies.append(E_val)\n",
    "                print(f\"  Successfully processed: {len(phases)} eigenphases\")\n",
    "            else:\n",
    "                print(f\"  Skipping E={E_val:.3f}: insufficient valid phases\")\n",
    "            \n",
    "        except Exception as e:\n",
    "            print(f\"  Error at E={E_val:.3f}: {e}\")\n",
    "            continue\n",
    "    \n",
    "    print(f\"Successfully calculated S-matrices for {len(all_S_matrices)} energies\")\n",
    "    return all_eigenphases, all_S_matrices, valid_energies\n",
    "\n",
    "# Define energy range (adjust based on computational resources)\n",
    "energy_min, energy_max = 1.5, 2.3\n",
    "n_energies = 5  # Start small for testing\n",
    "energy_range = np.linspace(energy_min, energy_max, n_energies)\n",
    "\n",
    "# Calculate level statistics\n",
    "all_phases, all_S_mats, valid_energies = calculate_level_statistics(\n",
    "    energy_range, j_vals, x, dx, N, n_ch, mass, hbar, I_0\n",
    ")\n",
    "\n",
    "print(f\"\\nSummary:\")\n",
    "print(f\"Total energies attempted: {len(energy_range)}\")\n",
    "print(f\"Successfully processed: {len(valid_energies)}\")\n",
    "print(f\"Valid energies: {valid_energies}\")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 172,
   "id": "34a30e15",
   "metadata": {},
   "outputs": [],
   "source": [
    "def analyze_level_spacings(all_eigenphases):\n",
    "    \"\"\"Analyze level spacing statistics\"\"\"\n",
    "    all_spacings = []\n",
    "    all_ratios = []\n",
    "    \n",
    "    print(\"Analyzing level spacings...\")\n",
    "    \n",
    "    for i, phases in enumerate(all_eigenphases):\n",
    "        # Sort phases and calculate spacings\n",
    "        sorted_phases = np.sort(phases)\n",
    "        spacings = np.diff(sorted_phases)\n",
    "        \n",
    "        # Remove very small spacings (numerical artifacts)\n",
    "        spacings = spacings[spacings > 1e-6]\n",
    "        \n",
    "        if len(spacings) > 1:\n",
    "            # Normalize by mean spacing\n",
    "            mean_spacing = np.mean(spacings)\n",
    "            if mean_spacing > 1e-10:\n",
    "                normalized_spacings = spacings / mean_spacing\n",
    "                all_spacings.extend(normalized_spacings)\n",
    "                \n",
    "                # Calculate ratios for neighboring spacings\n",
    "                for j in range(len(spacings)-1):\n",
    "                    s1, s2 = spacings[j], spacings[j+1]\n",
    "                    ratio = min(s1, s2) / max(s1, s2)\n",
    "                    all_ratios.append(ratio)\n",
    "                \n",
    "                print(f\"  Energy {i+1}: {len(spacings)} spacings, mean = {mean_spacing:.4f}\")\n",
    "    \n",
    "    return np.array(all_spacings), np.array(all_ratios)\n",
    "\n",
    "def classify_chaos(mean_ratio):\n",
    "    \"\"\"Classify the system based on level spacing ratio\"\"\"\n",
    "    # Theoretical values:\n",
    "    # Poisson (regular): ~0.386\n",
    "    # GOE (chaotic): ~0.536\n",
    "    # GUE (chaotic with time-reversal broken): ~0.603\n",
    "    \n",
    "    if mean_ratio > 0.53:\n",
    "        return \"Chaotic (GOE-like)\"\n",
    "    elif mean_ratio < 0.39:\n",
    "        return \"Regular (Poisson-like)\"\n",
    "    else:\n",
    "        return \"Intermediate\"\n",
    "\n",
    "# Analyze spacings if we have data\n",
    "if len(all_phases) > 0:\n",
    "    spacings, ratios = analyze_level_spacings(all_phases)\n",
    "    \n",
    "    if len(spacings) > 5 and len(ratios) > 5:\n",
    "        # Calculate statistics\n",
    "        mean_spacing = np.mean(spacings)\n",
    "        std_spacing = np.std(spacings)\n",
    "        mean_ratio = np.mean(ratios)\n",
    "        std_ratio = np.std(ratios)\n",
    "        \n",
    "        print(f\"\\n{'='*50}\")\n",
    "        print(f\"LEVEL SPACING STATISTICS\")\n",
    "        print(f\"{'='*50}\")\n",
    "        print(f\"Number of spacings analyzed: {len(spacings)}\")\n",
    "        print(f\"Number of ratios analyzed: {len(ratios)}\")\n",
    "        print(f\"Mean normalized spacing: {mean_spacing:.4f} ± {std_spacing:.4f}\")\n",
    "        print(f\"Mean spacing ratio: {mean_ratio:.4f} ± {std_ratio:.4f}\")\n",
    "        \n",
    "        # Classification\n",
    "        chaos_classification = classify_chaos(mean_ratio)\n",
    "        print(f\"System classification: {chaos_classification}\")\n",
    "        \n",
    "        # Additional chaos indicators\n",
    "        print(f\"\\nChaos Indicators:\")\n",
    "        print(f\"- Ratio < 0.39: Regular/Integrable\")\n",
    "        print(f\"- Ratio ≈ 0.536: Chaotic (GOE)\")\n",
    "        print(f\"- Ratio > 0.53: Chaotic\")\n",
    "        print(f\"- Current ratio: {mean_ratio:.4f}\")\n",
    "        \n",
    "    else:\n",
    "        print(\"Insufficient data for meaningful level spacing analysis\")\n",
    "        print(f\"Got {len(spacings)} spacings and {len(ratios)} ratios\")\n",
    "        print(\"Need at least 5 of each for reliable statistics\")\n",
    "else:\n",
    "    print(\"No eigenphases calculated - check energy range and parameters\")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 173,
   "id": "bde758da",
   "metadata": {},
   "outputs": [],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "\n",
    "# Visualization of results\n",
    "if len(all_phases) > 0 and len(spacings) > 5:\n",
    "    \n",
    "    fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(15, 12))\n",
    "    \n",
    "    # Plot 1: Level spacing histogram\n",
    "    ax1.hist(spacings, bins=min(20, len(spacings)//3), alpha=0.7, density=True, \n",
    "             color='blue', edgecolor='black')\n",
    "    ax1.set_xlabel('Normalized Level Spacing (s)')\n",
    "    ax1.set_ylabel('Probability Density P(s)')\n",
    "    ax1.set_title('Level Spacing Distribution')\n",
    "    ax1.grid(True, alpha=0.3)\n",
    "    \n",
    "    # Add theoretical curves if enough data\n",
    "    if len(spacings) > 20:\n",
    "        s_theory = np.linspace(0, 4, 100)\n",
    "        # Poisson: P(s) = exp(-s)\n",
    "        poisson = np.exp(-s_theory)\n",
    "        # Wigner-Dyson (GOE): P(s) = (π/2)s exp(-πs²/4)\n",
    "        wigner = (np.pi/2) * s_theory * np.exp(-np.pi * s_theory**2 / 4)\n",
    "        \n",
    "        ax1.plot(s_theory, poisson, 'r--', label='Poisson (Regular)', linewidth=2)\n",
    "        ax1.plot(s_theory, wigner, 'g--', label='Wigner (Chaotic)', linewidth=2)\n",
    "        ax1.legend()\n",
    "    \n",
    "    # Plot 2: Ratio histogram\n",
    "    if len(ratios) > 5:\n",
    "        ax2.hist(ratios, bins=min(15, len(ratios)//3), alpha=0.7, density=True, \n",
    "                 color='orange', edgecolor='black')\n",
    "        ax2.axvline(x=mean_ratio, color='red', linestyle='-', linewidth=2, \n",
    "                   label=f'Mean = {mean_ratio:.3f}')\n",
    "        ax2.axvline(x=0.386, color='blue', linestyle='--', label='Poisson (0.386)')\n",
    "        ax2.axvline(x=0.536, color='green', linestyle='--', label='GOE (0.536)')\n",
    "        ax2.set_xlabel('Spacing Ratio r = min(s₁,s₂)/max(s₁,s₂)')\n",
    "        ax2.set_ylabel('Probability Density P(r)')\n",
    "        ax2.set_title('Spacing Ratio Distribution')\n",
    "        ax2.legend()\n",
    "        ax2.grid(True, alpha=0.3)\n",
    "    \n",
    "    # Plot 3: Eigenphases vs Energy\n",
    "    if len(valid_energies) > 1:\n",
    "        for i, (E, phases) in enumerate(zip(valid_energies, all_phases)):\n",
    "            ax3.scatter([E]*len(phases), phases, alpha=0.6, s=20)\n",
    "        ax3.set_xlabel('Energy')\n",
    "        ax3.set_ylabel('Eigenphases (radians)')\n",
    "        ax3.set_title('Eigenphase Evolution with Energy')\n",
    "        ax3.grid(True, alpha=0.3)\n",
    "    \n",
    "    # Plot 4: S-matrix properties vs Energy\n",
    "    if len(all_S_mats) > 1:\n",
    "        condition_numbers = []\n",
    "        determinants = []\n",
    "        \n",
    "        for S_mat in all_S_mats:\n",
    "            condition_numbers.append(np.linalg.cond(S_mat))\n",
    "            determinants.append(np.abs(np.linalg.det(S_mat)))\n",
    "        \n",
    "        ax4_twin = ax4.twinx()\n",
    "        line1 = ax4.semilogy(valid_energies, condition_numbers, 'b-o', label='Condition Number')\n",
    "        line2 = ax4_twin.plot(valid_energies, determinants, 'r-s', label='|det(S)|')\n",
    "        \n",
    "        ax4.set_xlabel('Energy')\n",
    "        ax4.set_ylabel('Condition Number', color='b')\n",
    "        ax4_twin.set_ylabel('|det(S)|', color='r')\n",
    "        ax4.set_title('S-Matrix Properties vs Energy')\n",
    "        ax4.grid(True, alpha=0.3)\n",
    "        \n",
    "        # Combine legends\n",
    "        lines1, labels1 = ax4.get_legend_handles_labels()\n",
    "        lines2, labels2 = ax4_twin.get_legend_handles_labels()\n",
    "        ax4.legend(lines1 + lines2, labels1 + labels2, loc='upper right')\n",
    "    \n",
    "    plt.tight_layout()\n",
    "    plt.show()\n",
    "    \n",
    "    # Summary table\n",
    "    print(f\"\\n{'='*60}\")\n",
    "    print(f\"CHAOS ANALYSIS SUMMARY\")\n",
    "    print(f\"{'='*60}\")\n",
    "    print(f\"Energy range: {energy_min:.2f} - {energy_max:.2f}\")\n",
    "    print(f\"Number of energies analyzed: {len(valid_energies)}\")\n",
    "    print(f\"Total eigenphases: {sum(len(phases) for phases in all_phases)}\")\n",
    "    print(f\"Mean spacing ratio: {mean_ratio:.4f} ± {std_ratio:.4f}\")\n",
    "    print(f\"System classification: {chaos_classification}\")\n",
    "    print(f\"Unitarity check: All S-matrices should be unitary\")\n",
    "    \n",
    "else:\n",
    "    print(\"Insufficient data for visualization\")\n",
    "    print(f\"Number of energy points with data: {len(all_phases)}\")\n",
    "    print(f\"Number of spacings: {len(spacings) if 'spacings' in locals() else 0}\")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "4a8561ba",
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "8528ce80",
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "925700de",
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "bfa41219",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
